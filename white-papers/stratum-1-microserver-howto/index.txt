== Stratum-1-Microserver HOWTO ==
:description: Building and configuring a tiny Stratum 1 timeserver
:keywords: Raspberry Pi, Odroid, BeagleBone, NTP, NTPsec, time service
:home: http://www.catb.org/esr/faqs/stratum-1-microserver-howto/
:adahat: https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi
:upuhat: https://store.uputronics.com/index.php?route=product/product&path=60_64&product_id=81
:dxhat: http://www.dx.com/p/add-on-gps-module-gps-hat-module-for-raspberry-pi-2-model-b-b-424254
by Eric S. Raymond
version 0.8

== Introduction ==

This HOWTO gives complete instructions for building a headless Stratum
1 timeserver using a Raspberry Pi or workalike SBC (= Single Board
Computer), a GPS HAT (= daughterboard designed for the Pi and
workalikes), and NTPsec <<NTPSEC>>.  Total parts cost should be about
$80.  Beginner-level light soldering may be required.

Why do it?  It's cheap, fun, and because your NTP server is running on
a dedicated machine you won't have so much jitter due to variable
load.

A GPS daughterboard (what Pi folks call a HAT after the Pi's interface
specification, Hardware Attached on Top) is a better idea than an
external GPS because a HAT uses an internal RS-232 interface that cuts
latency and jitter compared to a USB GPS, and provides the 1PPS signal
required for precision time service.  Generic USB GPSes do not deliver
this signal and therefore cannot be used for Stratum 1 service
footnote:[There is one line of USB GPSes, the Navisys
GR601-W/GR701-W/GR801-W, that provides 1PPS.].

Most of this build is actually independent of any one daughterboard's
hardware idiosyncracies. The build may also generalize to other
HAT-compatible Unix SBCs such as the Odroid C2, though details of
those remain to be filled in. To emphasize which parts of the build
won't vary versus those that will, we will refer to the main board as
"SBC" for the invariant parts and as "Pi", "Pi 2", "Pi 3", or "Odroid"
for the board-specific parts.

Where this HOWTO says "I" it refers to the author's direct experience;
"we" includes both the author and various technical experts who
assisted in the preparation of this document.

This tutorial assumes some basic Unix competence. You will not need to
be a programmer or an expert system administrator; you will need to
know your way around the command line a little and how to edit files.

Final note: if you're looking for instructions on setting up time
service with a conventional PS and cable-attached GPS, see <<GPSD-SERVICE>>.

== Parts list and hardware assembly ==

You will need:

* One Raspberry Pi or workalike SBC such as the Odroid C2.  I used a
  Raspberry Pi 3: these instructions cover older variants as well.

* One compatible GPS HAT.  Possibilities are:

[width="50%",frame="topbot",options="header"]
|=======================================================================
| HAT type                                 | Battery | Build status
| {adahat}[Adafruit GPS HAT]               | CR1220  | Tested
| {upuhat}[Uputronics GPS Expansion Board] | CR2032  | Tested
| {dxhat}[SKU 424254]                      |    -    | Tested
|=======================================================================

* One 3.3-volt lithium button cell (except the SKU 424254, which is
  powered by an on-board supercap, included).  The CR1220 is cheapest
  ordered from Adafruit along with the HAT, but you can buy compatible
  button cells at most places that carry hearing-aid batteries.

* A micro-SD reader/writer for making bootable OS images.

* A micro-SD card. 1GB is minimal. 4GB is plenty.

* A Linux host machine and a live Ethernet cable on which your Pi can
  see your local network and the Internet.

* (Optional) A case to protect your hardware from dust and curious
  felines.

* (Optional) 2 hex standoffs, 11mm with M2.5 threading, compatible
  screws.  Adafruit sells these <<STANDOFFS>>. They are the very
  similar to standard spacers used in PC cases; if you keep the small
  parts from old PCs around you'll have a dozen of them and probably
  the screws to match.

The Adafruit and Uputronics HATs are shipped as two parts each, a circuit
board and a 40-pin header. The SKU 424254 comes presoldered.  The
header on the Uputronics board snugs ino an on-board fitting and does
not requre soldering.

Note that if you're going to use a CR2032 with the Uputronics, a
jumper on the board needs to be desoldered.  It lives in a white box
outline near the + pole of the battery cradle. As shipped, it is
covered by a small dome of solder.

The header on the assembled HAT will fit down over the double row of pins
on one edge of the SBC, such that when fully assembled the SBC and HAT will
make a neat stack with all four pairs of corner holes vertically aligned.

. Find "north" on the HAT.  It's the edge the GPS module is
closest to and has a rectangular notch in it.  On the Adafruit HAT,
if you hold up the board so the "north" edge is at the top the
Adafruit logo will be right-side up.

. If you have them, screw the the two hex standoffs to the corner
holes on the west side of the SBC, female end up.  These will
support the HAT.

. Mate the female side of the detached 40-pin header with the
40-pin GPIO connector on the east edge of the SBC.  If your HAT
is pre-soldered, your boards are now stacked and you skip the next step.

. Lay the HAT over the board in such a way that the two sets of 4
corner holes line up and the header pins poke through a matching 40
holes in the HAT.  The GPS module and battery clip should face
upwards. If you added standoffs, they should match the corner holes of
the HAT. Solder each header pin into its through-hole. This is the last
bit of hardware hacking absolutely required.

. If you added standoffs, now secure the HAT to their
female-threaded upper ends using the screws.  This will help
protect the headers and pins from mechanical stress if the
assembly is dropped or has something sat on it.

. Optional: put the combination into a case.  Anything sold as a
"Raspberry Pi" case ought to do for the Adafruit HAT, because a single
HAT doen't project above the USB & Ethernet connectors on the SBC. The
Raspberry Pi Foundation Case qualifies, but for functional reasons we
recommend a transparent case.  The Adafruit 2258 case <<2258>>, for
example, should do nicely.  The Uputronic and SKU 424254 HATs, alas,
have projecting SMA antenna jacks that won't fit in a stock case. A
bit of work with a dremel will fix that.

== Understanding the GPIO connector ==

The pins you'll plug the HAT into are the SBC's primary or P1 GPIO
(General Purpose I/O) header.  There's a second or P5 GPIO connector
near it consisting of a 2x3 array of through holes. This build won't
use that.

The Pi 3, other recent Pi variants, and the Odroid have 40 pins in the
P1 header.  Older variants, the original Pi A and B, have only 26
pins.  The assignments for those pins on later versions are
backward-compatible.

The GPIO pins are sometimes referenced by physical pin location on the
header (1-26 or 1-40), and sometimes as the GPIO line connected to the
CPU.  This can cause confusion, especially since some kit-builders use
variant GPIO numberings.  All GPIO numbers in this HOWTO reference
<<PI-PINOUT>>.

Physical pins are best referred to as P1-[1-40], P5-[1-8] or as
GPIO[0-31].  Some are typically pre-configured for specific functions
(serial, i2c, etc.)  Two that will be important for this build are the
TX and RX serial lines attached to the SBC's UART.

== Configuration overview ==

The steps in this configuration sequence have been carefully ordered
to commit you to as few changes that are difficult to reverse as
possible before you are certain you can make the hardware work as
a dedicated timeserver.

The work divides into the following phases:

1. Early configuration

2. Smoke-test the SBC/HAT combination

3. Live-test the GPS

4. Build and configure NTPsec

5. Installation and boot-time setup

6. Secure the machine.

7. Performance tuning

8. Simplification and optimization

Within each phase, we try to indicate how difficult each operation is
to back out.

This recipe consists of a few commands run on your host machine, and
more on your SBC.  A '#' before a command line means you need to be
root to run it. Some commands won't require root; those command lines
will be marked with "$".  Remember that you go root with the command
"sudo bash" or (after you haves set a root password) "su -".

=== Making a bootable SD ===

Download the link:2016-03-18-raspbian-jessie-lite.zip[2016-03-18
Raspbian Lite image zip file] to your host.  Note: due to brain-dead
configuration of the GPIO pins <<UART-ISSUE>>, you cannot use the
2016-05-10 image from <<RASPBIAN>>. We hope this will be fixed in a
future release.

Use sha1sum to verify the correctness of the image.

------------------------------------------------------------------------
$ sha1sum 2016-03-18-raspbian-jessie-lite.zip
9d4c33fe027a0411bf78181f4c2a0a5ba1f97e31  2016-03-18-raspbian-jessie-lite.zip
------------------------------------------------------------------------

The hex string this command returns should match the SHA-1 checksum
above.  If it doesn't, you have a corrupted image and should re-fetch
it.

Note that this is not the regular NOOBS image, but one specifically
designed to boot the Pi as a headless server, communicated with only
by Ethernet. By going this route we get to avoid some hardware
prerequisites that would never be used after install, and skip a bunch
of steps in removing unnecessary desktop software.

Unzip it to get an img file:

------------------------------------------------------------------------
$ unzip 2016-03-18-raspbian-jessie-lite.zip
------------------------------------------------------------------------

Install dcfldd on your host machine:

------------------------------------------------------------------------
# apt-get install dcfldd
------------------------------------------------------------------------

You can use the older 'dd' for the next step, but dfcldd is better
about giving you progress messages during the operation.

Insert an SD card in the reader and plug the reader into a USB port on
your host.  Note: your host may automount the card if it has been set
up for Linux before.  You should unmount it.

Follow the directions at <<INSTALLATION>>, using dfcldd.  On a
host running Debian or Ubuntu, the device will likely be /dev/sdd and
your command will look something like:

------------------------------------------------------------------------
# dcfldd bs=4M if=2016-03-18-raspbian-jessie-lite.img of=/dev/sdd
------------------------------------------------------------------------

We provide a script, link:ddimage[ddimage], to semi-automate this process.
Read it. You should always read any script that will run with root
permissions, to check that it doesn't do anything nefarious.  Give
it the basename of your SD reader (usually "sdd"). It will do some sanity
checks, then generate a command like the above.

Your ddimage command execution should look like this:

------------------------------------------------------------------------
# ddimage sdd
Checking /dev/sdd
/dev/sdd exists as a mountable device.
/dev/sdd is not mounted
Copying...
256 blocks (1024Mb) written.
324+1 records in
324+1 records out
Done.
------------------------------------------------------------------------

Note: this can take a while.

When this command completes, take the card out of the SD reader and
insert it into your Pi. Make sure your Pi has a live Ethernet cable
plugged in and connected to the same network as your host (because it
will also need to see the general Internet, direct-connecting to your
PC is insufficlent). Power it up and wait about 60 seconds, then do
this from your host:

------------------------------------------------------------------------
$ ssh pi@raspberrypi.local
------------------------------------------------------------------------

If ssh tells you it can't see any host named 'raspberrypi.local',
either the Pi hasn't yet booted or your network can't see it. Don't
panic. Check for a green light on the Pi's Ethernet port to be sure
it's plugged in properly. Make sure your SD card is right-side-up and
properly seated. Wait 30 seconds and try again.

Only persistent failure after you've tried these things mean you need
to rebuild the SD card image. Try with a different card, as sometimes
older ones go flaky.

You may see some noise from ssh about an unknown host; tell it yes,
you want to connect.  Then you should be asked for a login password. The
default Pi password is "raspberry".  Entering that should give you
a shell prompt.

The hardest part is now done.

=== Initial configuration ===

Call 'sudo raspi-config' on the Pi.  

Request 'Expand Filesystem' by keying Return with the select bar on
that entry.  This will make all the space on the SD above the end of
your copied OS image available on next reboot.

Request 'Wait for Network at Boot'.  This makes recovery a little
more convenient if you power up the SBC forgetting to plug in
the Ethernet cable.

Go through your normal configuration - timezone, locale, etc.  These
are under "Internationalization Options".  In the US, you probably
want en_US.UTF-8; in any other country, look for your ISO language
code followed by ".UTF-8". Also, set up WiFi country.

Under 'Advanced Options' (9), change your hostname to something
entertaining (A2). If you forget to do this, you can edit /etc/hostname
later on.

One special thing you should do is disable the serial interface (A8).
Your HAT needs the GPIO pins it uses, and it's easiest to disable from
the configurator.

You will be asked if you want to reboot after configuring.  Tell it
yes, then log back in using the new hostname followed by ".local".

=== Fully update Your OS ===

Most of the remaining instructions do not have to be done by hand.  You can
download link:clockmaker[clockmaker], a Python script which
does much of this recipe for you. Here's how to use it:

1. Copy clockmaker to to the pi user's home directory with
   this command:
+
[subs="attributes"]
------------------------------------------------------------------------
wget {home}clockmaker
------------------------------------------------------------------------

2. Read it. You should always read any script that will run with root
   permissions, to check that it doesn't do anything nefarious.

3. Make clockmaker executable with "chmod a+x clockmaker".

4. Go root. Then run "clockmaker --config". This will do most of the
   tricky OS and hardware configuration; also system software
   downloads and prerequisites for the timeserver software

5. Leave root. Then run "clockmaker --build".  This will clone and build the
   special timeserver software.

Some further uses of clockmaker are discussed in later steps.

The clockmaker script is intelligent about not redoing steps it has
already done; it is safe to run each stage multiple times.  Redoing
the --build step re-pulls from the software repositories.

In the recipe that follows, steps marked "{--config}" or "{--build}"
are parts clockmaker will do for you if you run it.  It is
recommended that you read the steps to understand the process, then
use clockmaker to avoid most of the typing.

At this point the steps you can automate with clockmaker begin.  If
you have not downloaded clockmaker, refer to "Using Clockmaker" above. 
Go root on the SBC and run "./clockmaker --config".

{--config} Fully update the Linux on your SBC.  The easiest way to do this is
with these commands:

------------------------------------------------------------------------
$ sudo bash
# apt-get update
# apt-get dist-upgrade
------------------------------------------------------------------------

These changes are not reversible, but you'd want them for any other
use of the SBC anyway.

=== Pi 3 only: disable Bluetooth and remap console device ===

The Raspberry Pi Foundation made a design decision on the Raspberry
Pi 3 that ties the serial baud rate to the CPU clock rate (by
default).  This was done because the normal lines that fed the serial
port were used for the built-in Bluetooth. This does not affect any
other Pi variant.

Your timeserver is not going to need Bluetooth, so you should
disable it and remap the devices.  Our instructions come from
<<DOREY>>, which explains the problem in more detail.  We don't use
some of his steps because this build is designed to run headless.

{--config} Edit the /boot/config.txt file to append these lines:

------------------------------------------------------------------------
# Disable Bluetooth so serial-tty speed is no longer tied to CPU speed
dtoverlay=pi3-miniuart-bt
------------------------------------------------------------------------

This change restores the behavior of the Pi2 and earlier, in which the
serial device attached to the UART is /dev/ttyAMA0 rather than /dev/ttyS0.

This change can effectively be reversed by commenting out the
dtoverlay and force_turbo lines.

{--config} To go with this, do:

------------------------------------------------------------------------
# systemctl disable hciuart
------------------------------------------------------------------------

{--config} Create a symlink to the GPS device to make it easier to refer
to.  Put the following in a new file /etc/udev/rules.d/10-pps.rules to
accomplish this:

------------------------------------------------------------------------
KERNEL=="ttyAMA0", SYMLINK+="gpsd0"
------------------------------------------------------------------------

=== Configure the 1PPS GPIO pin ==

You'll need NTPsec to be able to see the high-precision PPS
(pulse-per-second) signal from the GPS.  But the serial interface from
a HAT only supplies TX/RX; the PPS signal is shipped on a different
pin of the GPIO connector.

The RX/TX signals are always expected on the same two pins of the GPIO
(P8 and P10) which connect to the SBC's UART. You can see them,
labeled, near the north end of the connector. Most other GPIO pins can
be interpreted by the Pi in different ways, configured by software.
Which pin is used for 1PPS is a variable of the HAT design.  Here is a
table:

[width="25%",frame="topbot",options="header"]
|============================================
| Logical pin   | Physical pin  | HAT
|   GPIO04      |      P1-7     | Adafruit
|   GPIO18      |      P1-12    | Uputronics
|   GPIO05      |      PI-29    | SKU 424254
|============================================

//FIXME: Verify SKU 424254 info - check PI 29 with a scope

There is a different, non-HAT Adafruit product, the "Ultimate GPS
Breakout Board", that also uses GPIO18/P1-12.  This may be a source of
confusion if you read some of the references in this document.

There is a Linux kernel driver called pps-gpio which,
given one of these pins, uses the signal from it to support an
RFC2783 interface to PPS that NTPsec (and GPSD) can use.  To
see 1PPS, you need to ensure that this driver is loaded
and monitoring the correct logical pin.

The procedure for declaring the GPIO pin varies by Raspbian version.
We only give the formula for the current Raspbian here; you can
find details about older versions at <<TAYLOR>>;

{--config} Edit /boot/config.txt to contain these options, replacing '4' with
the logical pin number for your HAT if it's not an Adafruit:

------------------------------------------------------------------------
# Get 1PPS from HAT pin 
dtoverlay=pps-gpio,gpiopin=4
------------------------------------------------------------------------

You must reboot your SBC for this change to take effect.  The
clockmaker script will do this for you, but not before 
installing some packages need for the next step.

== Smoke-test the GPS/HAT combination ==

(Some material in this section is from <<ADAFRUIT-TEST>>.)

Next thing you want to do is verify that the GPS works.  Put your
SBC+HAT combination on someplace like a windowsill with a good sky
view outside.  The HATs this HOWTO describes have very good
weak-signal discrimination and are much less fussy about siting than
older GPS receivers.

Here's how to tell if your HAT has a fix.  The numbers are blink
intervals for the fix LED; "off" means the LED does not blink.

.Blink interval in seconds
[width="50%",frame="topbot",options="header"]
|=======================================================================
| HAT type                        | No fix |  Fix
| Adafruit GPS HAT                | 1      |  10
| Uputronics GPS Expansion Board  | off    |  1
| SKU 424254                      | 0.5    |  0.5
|=======================================================================

On first (cold) boot, the device may take 20-30 minutes to download a
satellite ephemeris. After that, time to get a fix should be much faster
unless you live in a canyon (including the urban kind) or dense forest.
I, living in a suburb with the front of my house half-screened by tall
trees, typically get lock about 30 seconds from power up.  It will
seem longer than it is first time: have patience.

=== GPS serial data ===

To test that you can read data from the device, do this:

------------------------------------------------------------------------
$ stty -F /dev/gpsd0 raw 9600 cs8 clocal -cstopb
$ cat /dev/gpsd0
------------------------------------------------------------------------

You should see NMEA0183 sentences issuing in bursts once per second -
text lines usually beginning with "$GP", and possibly a "$PMTK"
sentence.  These will issue whether or not the GPS has satellite lock.

If you see no output or see random baud barf, re-do the stty command being
very careful that all the arguments are correct. If you still don't
see output, check that the HAT is correctly seated on the GPIO and
powered up (a red light near the north edge should blink at least once
per 10 seconds).

If you still don't see legible output after checking these, you may
have a problem this HOWTO can't solve - possibly dead or defective
hardware.  However, it is far more likely that you have skipped
a previous step or gotten one slightly wrong. Recheck your work.

This was not a full functional test of the GPS; we'll do that latter.
It's what engineers call a "smoke test", just checking that the
device is alive and doing something reasonably sane.

=== 1PPS output ===

To test 1PPS, use ppstest from the pps-tools package.  Note,
this will produce a false negative if the GPS has no fix.

If you are doing these steps by hand rather than with clockmaker,
prepare with this step {--config}:

------------------------------------------------------------------------
# apt-get install pps-tools
------------------------------------------------------------------------

Then run this test:

------------------------------------------------------------------------
# ppstest /dev/pps0
------------------------------------------------------------------------

You should see repeated lines somewhat resembling this:

------------------------------------------------------------------------
source 0 - assert 1461161753.267392352, sequence: 246 - clear  0.000000000, sequence: 0
------------------------------------------------------------------------

If you can see this, you have 1PPS and can do proper timekeeping.

== Live-test the GPS ==

Now exit root, returning to the default-user account, and build GPSD.  If
you are using clockmaker, "./clockmaker --build" will automate
the build steps (but not the test procedures).

It's best to clone the GPSD repository and build
from that rather than installing the Raspbian package.  This both
guarantees you the latest fixes and avoids installing a start-on-boot
script that you don't want in this build.

The prerequisites not present in a stock Raspbian can be covered with
this import {--config}:

------------------------------------------------------------------------
# apt-get install git scons ncurses-dev python-dev bc
------------------------------------------------------------------------

Then do this {--build}:

------------------------------------------------------------------------
$ git clone git://git.savannah.nongnu.org/gpsd.git
$ cd gpsd
$ scons timeservice=yes nmea0183=yes fixed_port_speed=9600 fixed_stop_bits=1
------------------------------------------------------------------------

This builds gpsd in a minimal, fixed-speed timeserver mode.

Then run this: 

------------------------------------------------------------------------
# ./gpsd/gpsmon /dev/gpsd0
------------------------------------------------------------------------

Running gpsmon should give you a nice panel display with a scrolling
window at the bottom showing the raw data and a top section showing
the analyzed fix and time to the second.

If you have a fix, you should also see bars denoting 1PPS once per
second between sentence bursts.  If you have a fix and *don't* see
these, most likely you have forgotten to go root before running
gpsmon.

Next, check that gpsd is shipping time notifications via the
shared-memory interface required by ntpd. If you run ntpshmmon, you
should see time sample lines until you interrupt, looking something
like this:

------------------------------------------------------------------------
# ./gpsd/gpsd /dev/gpsd0
# ./gpsd/ntpshmmon
ntpshmmon version 1
#      Name   Seen@                Clock                Real               L Prec
sample NTP0 1462725362.567068197 1462725362.475583880 1462725362.000000000 0  -1
sample NTP1 1462725362.909592179 1462725362.908928852 1462725363.000000000 0 -20
sample NTP0 1462725363.067835766 1462725362.475583880 1462725362.000000000 0  -1
sample NTP1 1462725363.410437248 1462725362.908928852 1462725363.000000000 0 -20
sample NTP0 1462725363.568646773 1462725363.440431209 1462725363.000000000 0  -1
sample NTP1 1462725363.911264556 1462725363.908928951 1462725364.000000000 0 -20
------------------------------------------------------------------------

If this fails or hangs, check to make sure that you configured gpsd in
time-service mode and your GPS has a fix.  If you see only "NTP2"
lines, you forgot to go root before starting gpsd.

Having run this step, you now know that both data and 1PPS from the
HAT are fully visible on your SBC and gpsd collects them and provides
them over its shared-memory interface.  You can now proceed with
specializing your SBC to be a time server.

== Build and configure NTPsec ==

The stock ntpd shipped with your distribution is intended to be used as a
client instance, not a server.  It doesn't do 1PPS, and therefore
can't be used for precision timekeeping.  Thus, we're going to build a
better version from source.  That version is NTPsec, which runs
lighter and more securely and can do more accurate time stepping.

Install the build prerequisites {--config}:

------------------------------------------------------------------------
# apt-get install bison libevent-dev libcap-dev libssl-dev
# apt-get install libreadline-dev
------------------------------------------------------------------------

Build NTPsec {--build}.  The --refclock option says to include only
shared-memory refclock support, excluding all other drivers.

------------------------------------------------------------------------
$ git clone https://gitlab.com/NTPsec/ntpsec.git
$ cd ntpsec
$ ./waf configure --refclock=28
$ ./waf build
------------------------------------------------------------------------

Create your own NTP configuration with this contents as ntp.conf, but
don't copy it to /etc yet {--build}.  We're going to test this
configuration in place before installing it.

------------------------------------------------------------------------
include::ntp.conf[]
------------------------------------------------------------------------

Here's what the parts mean:

GPS Serial data reference (NTP0)::
   The line beginning "server 127.127.28.0" tells it we're expecting fixes
   via the shared-memory mailbox, unit 0.  These will be labeled GPS
   because they are the GPS's in-band time reports.

GPS Serial data reference (NTP0)::
   The line beginning "server 127.127.28.1" tells it we're expecting fixes
   via the shared-memory mailbox, unit 1.  These will be labeled PPS
   because they come from the GPS's 1PPS.

Internet time servers::
   This section specifies some NTP servers to act as a sanity
   check for our GPS time.

=== Smoke-test NTPsec ===

Turn off the default ntpd service running on your SBC

------------------------------------------------------------------------
# systemctl stop ntp
------------------------------------------------------------------------

Run gpsd, telling it to look at the GPS device

------------------------------------------------------------------------
# gpsd/gpsd /dev/gpsd0
------------------------------------------------------------------------

Run your newly built ntpd, telling it to step time if required:

------------------------------------------------------------------------
# ntpsec/build/main/ntpd/ntpd -g -c ntp.conf
------------------------------------------------------------------------

Run ntpsec/build/main/ntpq/ntpq -p and look at what it returns. Be patient,
as it can sometimes take a few seconds to complete.
------------------------------------------------------------------------
# ntpsec/build/main/ntpq/ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
+SHM(0)          .GPS.            0 l   58   64    3    0.000  -421.25 373.969
*SHM(1)          .PPS.            0 l   61   64    1    0.000   17.145   0.004
 nox.prolixium.c 200.98.196.212   2 u   26   64    1   44.090   20.648  16.170
 173.44.32.10    LOCAL(0)         6 u   26   64    1   32.017  -96.449  15.923
 2001:470:8d1c:c .GPPS.           1 u   28   64    1   56.784   23.883  19.294
 caprica.willgly 142.66.101.13    2 u   37   64    1   34.297   23.901  17.210
------------------------------------------------------------------------

You're hoping for a display like the above, with two local devices and
four pool sources.  A nonzero "reach" column on a source line
indicates that your ntp is getting time notifications from that
source.

If the value under "reach" for the SHM lines remains zero, check again that
gpsd is running and ntpshmmon reports fix lines.

=== Installation and boot-time setup ===

This step can be automated with "./clockmaker --install" done as root.

Uninstall the stock NTP:

------------------------------------------------------------------------
# apt-get -y remove --purge ntp
# apt-get -y autoremove
------------------------------------------------------------------------

Change to the directory your gpsd and ntpsec repository clones live and
install both suites:

------------------------------------------------------------------------
# cd gpsd; scons install
# cd ../ntpsec; ./waf install; cp ntp.conf /etc
------------------------------------------------------------------------

Install the pinup script:

------------------------------------------------------------------------
# cp pinup /usr/local/bin
------------------------------------------------------------------------

Install this text as the file /etc/init.d/timeservice and make it executable:

------------------------------------------------------------------------
include::timeservice[]
------------------------------------------------------------------------

The commands to do this are:

------------------------------------------------------------------------
# cp timeservice /etc/init.d; chmod a+x /etc/init.d/timeservice
------------------------------------------------------------------------

Install this text in the directory /etc/systemd/system/:

------------------------------------------------------------------------
include::timeservice.service[]
------------------------------------------------------------------------

The commands to do this are:

------------------------------------------------------------------------
# cp timeservice.service /etc/systemd/system/
------------------------------------------------------------------------

Enable startup at boot with:

------------------------------------------------------------------------
# systemctl enable timeservice
------------------------------------------------------------------------

What's going on here: the file /etc/init.d/timeservice is a System V init
script conforming to LSB conventions.  If you decide to ditch systemd
you can mame a link to it from, e.g. /etc/rc3.d and the right thing
will happen.  The file /etc/systemd/system/timeservice.service is
a systemd unit file that will call the System V init script to do the
real work.

Reboot.  Check that gpsd and ntpd are running, and use ntpq -p to
verify that you can see time samples coming in.

=== Secure the machine ===

Final parts of this step can be automated with "./clockmaker --secure"
done as root.

The fact that your SBC has a known default name and default user means
that it is very vulnerable to being attacked and exploited by anyone
who gets access to your network.  Here's how to fix this:

. On the SBC, create an account for "me" (whatever username you like)
  using 'adduser' run as root.

. On the SBC, add yourself to the 'sudo' and 'dialout' groups.
  The first is necessary; the second is optional but will make some
  later test steps easier.  Replace 'me' with the username you desire.
+
------------------------------------------------------------------------
# usermod -a -G sudo,dialout me
------------------------------------------------------------------------

. From the host, verify that you can log in via ssh under your own
  name and sudo to a root shell with "sudo bash"; you should see a "#"
  prompt.

. From the host, export an ssh key from the "me" account to the
  SBC. If you don't understand this instruction, search for "ssh
  tutorial on the web and learn.  The
  http://www.catb.org/~esr/sshexport/[sshexport] tool may be useful.

. Reboot the SBC. Verify that you can login via ssh from your host
  machine to the build account on the SBC without giving a password.
  Then go root.

. {--secure} On the SBC, disable the default-user login (on the RPi
  "deluser pi" as root).

. {--secure} On the SBC, disable root login and password tunneling. To
  do this, edit its /etc/ssh/sshd_config file.  Change the
  "PermitRootLogin" and "PasswordAuthentication" lines so the second
  token is "no".

You will probably want to re-fetch clockmaker and do a "clockmaker
--build" in your home directory.

== Performance tuning ==

Don't be overly concerned if ntpq -p initially shows large jitter.
This probably just means your clock was off by a few seconds - not
uncommon on SBCs without a battery-backed real-time clock.  Initially,
ntpd has no way to separate actual jitter from the clock offset
This will probably fix itself in a few hours of operation once ntpd
has pulled your system clock close to the PPS time.

For more about performance tuning and how to fudge your configuration,
see
http://www.catb.org/gpsd/gpsd-time-service-howto.html#_performance_tuning[the
GPSD Time Service HOWTO's section on tuning].

== Simplification and optimization ==

=== Thin out the system processes ===

The Raspbian default is to install a lot of background processes that
exist to support a graphical desktop. Installing from the Lite image
eliminates most of these.  This reduces load variability on the
processor, which will will decrease your time jitter.  It will also
cut your power draw and heat dissipation, increasing the Pi's expected
lifetime.  Most importantly, it will reduce the number of ways for
things to go wrong.

You can strip down a bit further with these commands:

------------------------------------------------------------------------
# apt-get -y remove --purge bluez
# apt-get -y remove --purge triggerhappy
# apt-get -y autoremove
# apt-get -y update
------------------------------------------------------------------------

The resulting configuration is pretty minimal, as you can verify by
running "ps ax" and noticing that most of the background processes are
kernel threads.

WiFi is deliberately not removed, in order to give
you a fallback TCP/IP access when a cable is inconvenient.

=== Configuring for a static IP address ==

You can choose to configure the SBC to use a fixed, static IP
address. That process is described in <<EAT-STATIC>>.

If you do this, and verify that it works, you
can remove avahi-daemon and dhcpd5, further
cutting the number of service processes running.

------------------------------------------------------------------------
# apt-get -y remove --purge avahi-daemon dhcpd5
------------------------------------------------------------------------

Once you do this, the SBC will no longer be accessible at a ".local"
address.

== Using pinup ==

We provide a script called link:pinup[pinup] that makes it easy to
query the configuration of your timeserver, and change its 1PPS
GPIO pin when required.

Call "pinup" without arguments to query the configuration:

------------------------------------------------------------------------
$ ./pinup
Raspberry Pi 3 Model B, configured for the Adafruit HAT.
------------------------------------------------------------------------

Calling "pinup -p" as root allows you to choose a GPIO pin for 1PPS
from a menu of daughterboard types.

== Technical notes for advanced users ==

=== Why GPSD? ===

If you are already familar with ntpd and wonder why this recipe uses
gpsd through SHM rather than ntpd's native refclock 20 GPS driver, the
answer is this: when refclock 20 is configured to use 1PPS, it mixes
in-band time data with 1PPS in a way that causes it to behave badly,
and possibly get rejected as a falseticker, when 1PPS is only
occasionally available.

=== Edge-detection issues and new HATs ===

The pps-gpio module as of April 2016 has a flaw. It catches only
one edge of the PPS. You have a 50/50 chance you are seeing the
trailing edge rather than the leading edge (which is the actual top of
second).  A patch to fix this has been submitted to the Linux kernel
maintainers but not merged.

Which edge the kernel will see, and the pulse width, are constant
depending on the GPS type and firmware (and if you can find a real
datasheet for the GPS engine it will tell you the pulse width). If the
kernel sees the trailing edge, the width of the pulse emitted by your
GPS will introduce a fixed lag from top of second to the time when you
actually see the PPS.

Pulse widths (and the induced lag) range from so fast the serial
driver can't see them to, worst case, 0.5s.  The worst case is rare;
typical pulse widths are 50 to 200ms. Because the error is constant,
you can compensate it out with an offset if you know what it is.
HATs marked "leading edge" below do not require compensation.

[width="25%",frame="topbot",options="header"]
|===========================================================
|Type           | Chipset    | 1PPS width  | gps-ppio detects
|Adafruit HAT   | MTK3339    |   100ms     | leading edge
|Uputronics HAT | Ublox 8    |   100ms     | leading edge 
|SKU 424254     | Ublox 6    |   100ms     | leading edge
|===========================================================

//FIXME: Verify SKU 424254 info with a scope

These details will become relevant whenever we qualify a new HAT
for coverage in this HOWTO.  The important thing to check is whether
the pps-gpio driver triggers on leading or trailing edge.

== A note about the Odroid C2 ==

The Odroid C2 is an ARM-based hackerboard strongly resembling the
Raspberry Pi, but with better hardware and at a slighly higher price
point. The main connector on the Odroid is pin-compatible with the
40-pin Pi connector.  A company representative has stated that
forum.odroid.com/viewtopic.php?f=111&t=7660[the Adafruit HAT should
work with it]

This recipe has not been tested with the Odroid.  But we can give
some pointers towards making it work.

* Your configuration and first-login process will be slighly different,
  as your Odroid will be running a stock Ubuntu rather than Raspbian.

* The company rep says that the UART device is /dev/ttyS2 rather
  than /dev/ttyAMA0, so you'll need to link /dev/ttyS2 to /dev/gps.

* The RPi 3 hack to disable serial interfaces won't be required.

We would welcome field reports to complete this recipe.

== Future Direction ==

Future versions of this HOWTO will broaden the hardware base to
include some BeagleBone variant.

== References ==

[bibliography]

- [[[GPSD-SERVICE]]] http://www.catb.org/gpsd/gpsd-time-service-howto.html[GPSD Time Service HOWTO]

- [[[STANDOFFS]]] https://www.adafruit.com/product/2336[Brass M2.5 Standoffs for Pi]

- [[2258]] https://www.adafruit.com/product/2258

- [[[PI-PINOUT]] https://www.element14.com/community/docs/DOC-73950/l/raspberry-pi-3-model-b-gpio-40-pin-block-pinout[Raspberry Pi 3 Model B GPIO 40 Pin Block Pinout]

- [[[UART-ISSUE]]] https://www.raspberrypi.org/forums/viewtopic.php?uid=191178&f=28&t=148218&start=0[UART Issue]

- [[[RASPBIAN]]] https://www.raspberrypi.org/downloads/raspbian/[Raspbian downloads]

- [[[INSTALLATION]]]
  https://www.raspberrypi.org/documentation/installation/installing-images/linux.md[Installing Operating System Images Under Linux]

- [[[NTPSEC]]] https://www.ntpsec.org/[The NTPsec project]

- [[[DOREY]]] http://www.briandorey.com/post/Raspberry-Pi-3-UART-Overlay-Workaround[Raspberry Pi 3 UART Overlay Workaround]

- [[[ADAFRUIT-SETUP]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/pi-setup[Pi GPS Setup]

- [[[ADAFRUIT-TEST]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/basic-test[Basic Test]

- [[[TAYLOR]]] http://www.satsignal.eu/ntp/Raspberry-Pi-quickstart.html[RPi quick start]

- [[[EAT-STATIC]]] http://www.modmypi.com/blog/tutorial-how-to-give-your-raspberry-pi-a-static-ip-address[Tutorial - How to give your Raspberry Pi a Static IP Address]

== Acknowledgements ==

Various devteam members and friends of the GPSD and NTPsec projects
assisted with this HOWTO, including: Gary E. Miller, Hal Murray, and
Phil Salkie.

== Other resources ==

http://ava.upuaut.net/?p=726[Not quite 5 minute guide to making an NTP Server]

//end
