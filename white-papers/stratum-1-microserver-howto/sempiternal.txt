== Stratum-1-Microserver HOWTO ==
:description: Building and configuring a tiny Stratum 1 timeserver
:keywords: Raspberry Pi, Odroid, BeagleBone, NTP, NTPsec, time service
:adahat: https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi
:upuhat: https://store.uputronics.com/index.php?route=product/product&path=60_64&product_id=81
:dxhat:http://www.dx.com/p/add-on-gps-module-gps-hat-module-for-raspberry-pi-2-model-b-b-424254
by Eric S. Raymond
version 0.6

THIS IS AN INCOMPLETE DRAFT

== Introduction ==

This HOWTO gives complete instructions for building a headless Stratum
1 timeserver using a Raspberry Pi or workalike SBC (= Single Board
Computer), a GPS HAT (= daughterboard designed for the Pi and
workalikes), and NTPsec <<NTPSEC>>.  Total parts cost should be about
$80.  Beginner-level light soldering may be required.

Why do it?  It's cheap, fun, and because your NTP server is running on
a dedicated machine you won't have so much jitter due to variable
load.

A GPS daughterboard (what Pi folks call a HAT after the Pi's interface
specification, Hardware Attached on Top) is a better idea than an
external GPS because a HAT uses an internal RS-232 interface that cuts
latency and jitter compared to a USB GPS, and provides the 1PPS signal
required for precision time service.  Generic USB GPSes do not deliver
this signal and therefore cannot be used for Stratum 1 service
footnote[There is one line of USB GPSes, the Navisys
GR601-W/GR701-W/GR801-W, that provides 1PPS.  Unfortunately, it is
difficult to purchase in the U.S.].

Most of this build is actually independent of any one daughterboard's
hardware idiosyncracies. The recipe was tested using an Adafruit GPS
HAT, but some alternatives are given in a table in the parts list.

The build may also generalize to other HAT-compatible Unix SBCs such as
the Odroid C2, though details of those remain to be filled in. To
emphasize which parts of the build won't vary versus those that
will, we will refer to the main board as "SBC" for the invariant parts
and as "Pi", "Pi 2", "Pi 3", or "Odroid" for the board-specific parts.

Where this HOWTO says "I" it refers to the author's direct experience;
"we" includes both the author and various technical experts who
assisted in the preparation of this document.

This tutorial assumes some basic Unix competence. You will not need to
be a programmer or an expert system administrator; you will need to
know your way around the command line a little and how to edit files.

== Parts list and hardware assembly ==

You will need:

* One Raspberry Pi or workalike SBC such as the Odroid C2.  I used a
  Raspberry Pi 3: these instructions cover older variants as well.

* One compatible GPS HAT.  Possibilities are:

[width="50%",frame="topbot",options="header"]
|=======================================================================
| HAT type                                 | Battery | Build status
| {adahat}[Adafruit GPS HAT]               | CR1220  | Tested
| {upuhat}[Uputronics GPS Expansion Board] | CR2032  | Untested
| {dxhat}SKU 424254                        |    -    | Untested
|=======================================================================

* One 3.3-volt lithium button cell (except the SKU 424254, which is
  powered by an on-board supercap, included).  The CR1220 is cheapest
  ordered from Adafruit along with the HAT, but you can buy compatible
  button cells at most places that carry hearing-aid batteries.

* A micro-SD reader/writer for making bootable OS images.

* A micro-SD card.  1GB is minimal. 4GB is plenty.

* A Linux host machine and a live Ethernet cable on which your Pi can
  see your local network and the Internet.

* (Optional) A case to protect your hardware from dust and curious
  felines.  Any case with a 30mm or greater exterior height should be
  able to hold both SBC and HAT.

* (Optional) 2 hex standoffs, .625" with M2.5 threading, 4 compatible
  screws.  Adafruit sells these <<STANDOFFS>>. They are the very
  similar to standard spacers used in PC cases; if you keep the small
  parts from old PCs around you'll have a dozen of them and probably
  the screws to match.

The Adafruit and Uputronics HATs are shipped as two parts each, a circuit
board and a 40-pin header. The SKU 424254 comes presoldered.

(HATs are shipped as parts almost certainly to evade a regulatory
requirement for FCC conformance testing to RF emission standards,
which is expensive and would have added to the unit cost.)

Note that if you're going to use a CR2032 with the Uputronics, a
jumper on ther board needs to be desoldered.  It lives in a white box
outline near the + pole of the battery cradle.

The header on the assembled HAT will fit down over the double row of pins
on one edge of the SBC, such that when fully assembled the SBC and HAT will
make a neat stack with all four pairs of corner holes vertically aligned.

. Find "north" on the HAT.  It's the edge the GPS module is
closest to and has a rectangular notch in it.  On the Adafruit HAT,
if you hold up the board so the "north" edge is at the top the
Adafruit logo will be right-side up.

. If you have them, screw the the two hex standoffs to the corner
holes on the west side of the SBC, female end up.  These will
support the HAT.

. Mate the female side of the detached 40-pin header with the
40-pin GPIO connector on the east edge of the SBC.  If your HAT
is pre-soldered, your boards are now stacked and you skip the next step.

. Lay the HAT over the board in such a way that the two sets of 4
corner holes line up and the header pins poke through a matching 40
holes in the HAT.  The GPS module and battery clip should face
upwards. If you added standoffs, they should match the corner holes of
the HAT. Solder each header pin into its through-hole. This is the last
bit of hardware hacking absolutely required.

. If you added standoffs, now secure the HAT to their
female-threaded upper ends using the screws.  This will help
protect the headers and pins from mechanical stress if the
assembly is dropped or has something sat on it.

. Optional: put the combination into a case.  Anything sold as a
"Raspberry Pi" case ought to do, because a single HAT doen't project
above the USB & Ethernet connectors on the SBC. The Raspberry Pi
Foundation Case qualifies, but for functional reasons we recommend a
transparent case.  The Adafruit 2258 case <<2258>>, for example,
should do nicely.

== Understanding the GPIO connector ==

The pins you'll plug the HAT into are the SBC's primary or P1 GPIO
(General Purpose I/O) header.  There's a second or P5 GPIO connector
near it consisting of a 2x3 array of through holes. This build won't
use that.

The Pi 3, other recent Pi variants, and the Odroid have 40 pins in the
P1 header.  Older variants, the original Pi A and B, have only 26
pins.  The assignments for those pins on later versions are
backward-compatible.

The GPIO pins are sometimes referenced by physical pin location on the
header (1-26 or 1-40), and sometimes as the GPIO line connected to the
CPU.  This can cause confusion, especially since some kit-builders use
variant GPIO numberings.  All GPIO numbers in this HOWTO reference
<<PI-PINOUT>>.

Physical pins are best referred to as P1-[1-40], P5-[1-8] or as
GPIO[0-31].  Some are typically pre-configured for specific functions
(serial, i2c, etc.)  Two that will be important for this build are the
TX and RX serial lines attached to the SBC's UART.

== Configuration overview ==

The steps in this configuration sequence have been carefully ordered
to commit you to as few changes that are difficult to reverse as
possible before you are certain you can make the hardware work as
a dedicated timeserver.

The work divides into the following phases:

1. Early configuration

2. Smoke-test the SBC/HAT combination

3. Live-test the GPS

4. Build and configure NTPsec

5. Set up ntpd to run at boot time

6. Simplification and optimization

Within each phase, we try to indicate how difficult each operation is
to back out.

This recipe consists of a few commands run on your host machine, and
more on your SBC.  A '#' before a command line means you need to be
root to run it. Some commands won't require root; those command lines
will be marked with "$".  Remember that you go root with the command
"sudo bash" or (after you haves set a root password) "su -".

== Early configuration ==

=== Making a bootable SD ===

Download the Raspbian Lite image zip file from <<RASPBIAN>> to your
host.  The link will be named 'raspbian_lite_latest'.  The actual file
will be named something like '2016-03-18-raspbian-jessie-lite.img',
though probably with a later date.

Use sha1sum to verify the correctness of the image.  Something like
this:

------------------------------------------------------------------------
$ sha1sum 2016-03-18-raspbian-jessie-lite.zip
------------------------------------------------------------------------

The hex string this command returns should match the SHA-1 checksum
on the web page.  If it doesn't, you have a corrupted image and should
re-fetch it.

Note that this is not the regular NOOBS image. but one specifically
designed to boot the Pi as a headless server, communicated with only
by Ethernet. By going this route we get to avoid some hardware
prerequisites that would never be used after install, and skip a bunch
of steps in removing unnecessary desktop software.

Unzip it to get an img file:

------------------------------------------------------------------------
$ sha1sum 2016-03-18-raspbian-jessie-lite.zip
------------------------------------------------------------------------

Install dcfldd on your host machine:

------------------------------------------------------------------------
# apt-get install dcfldd
------------------------------------------------------------------------

You can use the older 'dd' for the next step, but dfcldd is better
about giving you progress messages during the operation.

Insert an SD card in the reader and plug the reader into a USB port on your host.

Follow the directions at <<INSTALLATION>>, using dfcldd.  On a
host running Debian or Ubuntu, the device will likely be /dev/sdd and
your command will look something like:

------------------------------------------------------------------------
# dcfldd bs=4M if=2016-03-18-raspbian-jessie.img of=/dev/sdd
------------------------------------------------------------------------

When this command complete, take the card out of the SD reader and
insert it into your Pi. Make sure your Pi has a live Ethernet cable
plugged in. Power it up and wait about 60 seconds footnote, then do this
from your host:

------------------------------------------------------------------------
$ ssh pi@raspberrypi.local
------------------------------------------------------------------------

If ssh tells you it can't see any host named 'raspberrypi.local',
either the Pi hasn't yet booted or your network can't see it. Don't
panic. Check for a green light on the Pi's Ethernet port to be sure
it's plugged in properly. Make sure your SD card is right-side-up and
properly seated. Wait 30 seconds and try again.

Only persistent failure after you've tried these things mean you need
to rebuild the SD card image. Try with a different card, as sometimes
older ones go flaky.

You may see some noise from ssh about an unknown host; tell it yes,
you want to connect.  Then you should be asked for a login password. The
default Pi password is "raspberry".  Entering that should give you
a shell prompt.

The hardest part is now done.

=== Secure the machine ===

The fact that your SBC has a known default name and default user means
that it is very vulnerable to being attacked and exploited by anyone
who gets access to your network.  Here's how to fix this:

. On the SBC, create an account for "me" (whatever username you like)
  using 'adduser' run as root.

. On the SBC, add add yourself to the 'sudo' and 'dialout' groups.
  The first is necessary; the second is optional but will make some
  later test steps easier.
+
------------------------------------------------------------------------
# usermod -a -G sudo,dialout me
------------------------------------------------------------------------

. From the host, verify that you can log in via "ssh me@raspberrypi.local"
  and sudo to a root shell with "sudo bash"; you should see a "#" prompt.

. On the SBC, disable the 'pi' login ("deluser pi" as root).

. From the host, export an ssh key from the "me" account to the
  SBC. If you don't understand this instruction, search for "ssh
  tutorial on the web and learn.  The
  http://www.catb.org/~esr/sshexport/[sshexport] tool may be useful.

. Reboot the SBC. Verify that you can login via ssh from "me" on your host
  machine to "me" on the SBC without giving a password.

. On the SBC, disable root login and password tunneling. To do
  this, edit its /etc/ssh/sshd_config file.  Change the
  "PermitRootLogin" and "PasswordAuthentication" lines so the
  second token is "no".

=== Initial configuration ===

Call 'sudo raspi-config' on the Pi.  

Request 'Expand Filesystem' by keying Return with the select bar on
that entry.  This will make all the space on the SD above the end of
your copied OS image available on next reboot.

Request 'Wait for Network at Boot'.  This makes recovery a little
more convenient if you power up the SBC forgetting to plug in
the Ethernet cable.

Go through your normal configuration - keyboard layout, timezone,
locale, etc.  In the U.S., you probably want en_US.UTF-8; in any other
country, look for your ISO language code followed by ".UTF-8".

Note: raspi-config seems to be a bit glitchy about building locales.
You may have to uncomment your locale in /etc/locale-gen, run
"locale-gen: as root, and then run raspi-config again in order to
select the one you want.

One special thing you should do is disable the serial interface (might
be A8 under 'Advanced Options').  Your HAT needs the GPIO pins it
uses, and it's easiest to disable from the GUI configurator.  This
change is easily reversed until and unless you strip out the GUI
later.

To change the machine's hostname, edit '/etc/hostname'.  You will
need to be root to do this.

=== Fully update Your OS ===

Fully update the Linux on your SBC.  The easiest way to do this is
with these commands:

------------------------------------------------------------------------
$ sudo bash
# apt-get update
# apt-get dist-upgrade
------------------------------------------------------------------------

These changes are not reversible, but you'd want them for any other
use of the SBC anyway.

=== Pi 3 only: disable Bluetooth and remap console device ===

The Raspberry Pi Foundation made a design decision on the Raspberry
Pi 3 that ties the serial baud rate to the CPU clock rate (by
default).  This was done because the normal lines that fed the serial
port were used for the built-in Bluetooth. This does not affect any
other Pi variant.

Your timeserver is not going to need Bluetooth, so you should
disable it and remap the devices.  Our instructions come from
<<DOREY>>, which explains the problem in more detail.  We don't use
some of his steps because this build is designed to run headless.

Check that you have the file
/boot/overlay/pi3-miniuart-bt-overlay.dtb; if you don't, you can
http://www.briandorey.com/docs/Raspberry-Pi-3-UART-to-gpio-workaround/pi3-miniuart-bt-overlay.zip[download]
it.

Edit the /boot/config.txt file to append these lines:

------------------------------------------------------------------------
# Disable Bluetooth so serial-tty speed is no longer tied to CPU speed
dtoverlay=pi3-miniuart-bt-overlay
------------------------------------------------------------------------

This change restores the behavior of the Pi2 and earlier, in which the
serial device attached to the UART is /dev/ttyAMA0 rather than /dev/ttyS0.

This change can effectively be reversed by commenting out the
dtoverlay and force_turbo lines.

=== Configure the 1PPS GPIO pin ==

You'll need NTPsec to be able to see the high-precision PPS
(pulse-per-second) signal from the GPS.  But the serial interface from
a HAT only supplies TX/RX; the PPS signal is shipped on a different
pin of the GPIO connector.

The RX/TX signals are always expected on the same two pins of the GPIO
(P8 and P10) which connect to the SBC's UART. You can see them,
labeled, near the north end of the connector. Most other GPIO pins can
be interpreted by the Pi in different ways, configured by software.
Which pin is used for 1PPS is a variable of the HAT design.  Here is a
table:

[width="25%",frame="topbot",options="header"]
|============================================
| Logical pin   | Physical pin  | HAT
|   GPIO04      |      P1-7     | Adafruit
|   GPIO18      |      P1-12    | Uputronics
|   GPIO05      |      PI-29    | SKU 424254
|============================================

//FIXME: Verify SKU 424254 info - check PI 29 with a scope

There is a different, non-HAT Adafruit product, the "Ultimate GPS
Breakout Board", that also uses GPIO18/P1-12.  This may be a source of
confusion if you read some of the references in this document.

There is a Linux kernel driver called pps-gpio which,
given one of these pins, uses the signal from it to support an
RFC2783 interface to PPS that NTPsec (and GPSD) can use.  To
see 1PPS, you need to ensure that this driver is loaded
and monitoring the correct logical pin.

The procedure for declaring the GPIO pin varies by Raspbian version.
We only give the formula for the current Raspbian here; you can
find details about older versions at <<TAYLOR>>;

Edit /boot/config.txt to contain these options, replacing '4' with
the logical pin number for your HAT if it's not an Adafruit:

------------------------------------------------------------------------
# Get 1PPS from HAT pin 
dtoverlay=pps-gpio,gpiopin=4
------------------------------------------------------------------------

You must reboot your SBC for this change to take effect.

== Smoke-test the GPS/HAT combination ==

(Some material in this section is from <<ADAFRUIT-TEST>>.)

Next thing you want to do is verify that the GPS works.  Put your
SBC+HAT combination on someplace like a windowsill with a good sky
view outside.  The HATs this HOWTO describes have very good
weak-signal discrimination and are much less fussy about siting than
older GPS receivers.

Here's how to tell if your HAT has a fix.  The numbers are blink
intervals for the fix LED; "on" means the device does not blink.

//FIXME: Fill in missing blink intervals.
//FIXME: Verify SKU 424254 info

.Blink interval in seconds
[width="50%",frame="topbot",options="header"]
|=======================================================================
| HAT type                        | No fix |  Fix
| Adafruit GPS HAT                | 1      |  10
| Uputronics GPS Expansion Board  | ?      |  ?
| SKU 424254                      | on     |  1
|=======================================================================

On first (cold) boot, the device may take 20-30 minutes to download a
satellite ephemeris. After that, time to get a fix should be much faster
unless you live in a canyon (including the urban kind) or dense forest.
I, living in a suburb with the front of my house half-screened by tall
trees, typically get lock about 30 seconds from power up.  It will
seem longer than it is first time: have patience.

=== GPS serial data ===

To test that you can read data from the device, do this:

------------------------------------------------------------------------
$ stty -F /dev/ttyAMA0 raw 9600 cs8 clocal -cstopb
$ cat /dev/ttyAMA0
------------------------------------------------------------------------

You should see NMEA0183 sentences issuing in bursts once per second -
text lines usually beginning with "$GP", and possibly a "$PMTK"
sentence.  These will issue whether or not the GPS has satellite lock.

If you see no output or random baud barf, re-do the stty command being
very careful that all the arguments are correct. If you still don't
see output, check that the HAT is correctly seated on the GPIO and
powered up (a red light near the north edge should blink at least once
per 10 seconds).

If you still don't see legible output after checking these, you may
have a problem this HOWTO can't solve - possibly dead or defective
hardware.  However, it is far more likely that you have skipped
a previous step or gotten one slightly wrong. Recheck your work.

This was not a full functional test of the GPS; we'll do that latter.
It's what engineers call a "smoke test", just checking that the
device is alive and doing something reasonably sane.

=== 1PPS output ===

To test 1PPS, use ppstest from the pps-tools package.  Note,
this will produce a false negative if the GPS has no fix.

------------------------------------------------------------------------
# apt-get install pps-tools
# ppstest /dev/pps0
------------------------------------------------------------------------

You should see repeated lines somewhat resembling this:

------------------------------------------------------------------------
source 0 - assert 1461161753.267392352, sequence: 246 - clear  0.000000000, sequence: 0
------------------------------------------------------------------------

If you can see this, you have 1PPS and can do proper timekeeping.

== Live-test the GPS ==

Now build GPSD.  It's best to clone the GPSD repository and build
from that rather than installing the Raspbian package.  This both
guarantees you the latest fixes and avoids installing a start-on-boot
script that you don't want in this build.

The prerequisites not present in a stock Raspbian can be covered with
this import:

------------------------------------------------------------------------
# apt-get install git scons ncurses-dev python-dev bc
------------------------------------------------------------------------

Then do this:

------------------------------------------------------------------------
$ git clone git://git.savannah.nongnu.org/gpsd.git
$ cd gpsd
$ scons timeservice=yes mtk3301=yes fixed_port_speed=9600 fixed_stop_bits=1
------------------------------------------------------------------------

This builds gpsd in a minimal, fixed-speed timeserver mode with only
the driver for the Adafruit HAT on it.  If you're using the Uputronics
or SKU 424254, use ublox=yes rather than mtk3301=yes.

Then run this: 

------------------------------------------------------------------------
# ./gpsmon /dev/ttyAMA0
------------------------------------------------------------------------

Running gpsmon should give you a nice panel display with a scrolling
window at the bottom showing the raw data and a top section showing
the analyzed fix and time to the second.

If you have a fix, you should also see bars denoting 1PPS once per
second between sentence bursts.  If you have a fix and *don't* see
these, most likely you have forgotten to go root before running
gpsmon.

Having run this step, you now know that both data and 1PPS from the
HAT are fully visible from userspace on your SBC.  You can
now proceed with specializing it to be a time server.

== Build and configure NTPsec ==

The stock ntpd shipped with your OS is intended to be used as a
client instance, not a server.  It doesn't do 1PPS, and therefore
can't be used for precision timekeeping.  Thus, we're going to build a
better version from source.  That version is NTPsec, which runs
lighter and more securely and can do more accurate time stepping.

Uninstall the stock NTP and tell apt-get not to upgrade it:

------------------------------------------------------------------------
# apt-get -y remove --purge ntp
------------------------------------------------------------------------

Then, clone the NTPsec repository:

------------------------------------------------------------------------
$ git clone https://gitlab.com/NTPsec/ntpsec.git
------------------------------------------------------------------------

Install the build prerequisites

------------------------------------------------------------------------
# apt-get install bison libevent-dev libcap-dev libssl-dev
# apt-get install libreadline-dev
------------------------------------------------------------------------

Build NTPsec.  The --refclock option says to include only Generic
NMEA and 1PPS support, excluding all other drivers.

------------------------------------------------------------------------
$ git clone https://gitlab.com/NTPsec/ntpsec.git
$ cd ntpsec
$ ./waf configure --refclock=20,22
$ ./waf build
------------------------------------------------------------------------

Next, create symlinks to the GPS devices to make them easier to refer
to.  Put the following in a new file /etc/udev/rules.d/10-pps.rules to
accomplish this.

------------------------------------------------------------------------
KERNEL=="ttyAMA0", SYMLINK+="gps0"  
KERNEL=="pps0", OWNER="root", GROUP="tty", MODE="0660", SYMLINK+="gpspps0"
------------------------------------------------------------------------

At boot time this will ensure that device aliases /dev/gps0 and
/dev/gpspps0 exist.  These are special names that NTPsec expects to see
when its Generic NMEA drive is active.

According to <<NEVILL>>, "[dhcpcd5] has a nasty habit of interfering where
it's not wanted. Specifically, in this instance, if your DHCP server
specifies an NTP server, it will start ntpd with its own version of
ntp.conf."

Look at /lib/dhcpcd/dhcpcd-hooks/50-ntp.conf to see if the hook script
exists.  If so, move it to a safe place (like your home directory) in
case you want to revert this change later.  You may want to similarly
stash /var/lib/ntp/ntp.conf.dhcp which is the autogenerated config file.

Create your own /etc/ntp.conf with this contents:

------------------------------------------------------------------------
# /etc/ntp.conf, configuration for ntpd; see ntp.conf(5) for help

# Local
server 127.127.1.0  
fudge 127.127.1.0 stratum 10

i# GPS with PPS enabled - mode 18 means expect 9600bps, use $GPGGA
server 127.127.20.0 mode 18 minpoll 4 maxpoll 4 iburst true prefer  
fudge 127.127.20.0 flag1 1 refid GPS

# Internet time servers for sanity
server 0.pool.ntp.org iburst prefer  
server 1.pool.ntp.org iburst  
server 2.pool.ntp.org iburst  
server 3.pool.ntp.org iburst

# By default, exchange time with everybody, but don't allow configuration.
restrict default kod nomodify notrap nopeer noquery  
restrict -6 default kod nomodify notrap nopeer noquery

# Local users may interrogate the ntp server more closely.
restrict 127.0.0.1  
restrict -6 ::1

# Drift file etc.
driftfile /var/lib/ntp/ntp.drift
------------------------------------------------------------------------

Here's what the parts mean:

Local::
   This section sets up a local clock that nptd can refer to if
   it can't connect to anything else.

GPS with PPS enabled::
   This section specifies the particulars for our GPS setup.
+
The line beginning "server 127.127.20.0" tells it that we have a serial GPS
receiver on /dev/gps0.

The text "mode 18" tells it to look for $GPGGA messages at a baud of 9600bps.

The text "prefer" declares the GPS your favored timeserver.

The line "fudge 127.127.20.0" tells it that we have some further
configuration for our GPS

flag1 1 tells it that we have a PPS interface from our GPS on /dev/gpspps0.

refid GPS tells it to label this time source with the reference "GPS".

Full documentation for the NTPsec NMEA driver can be found at <<NMEA-DRIVER>.

Internet time servers for sanity::
   This section specifies some NTP pool servers to act as a sanity
   check for our GPS time. They will also keep the time accurate if
   your GPS loses signal.

//FIXME: More to go here.  Use <<NEVILL>>
//Things still to be documented include:
//1. Testing ntpd. Point tp ntpq -p in the Time Service HOWTO.
//2. Startup installation scripts, including aetting AMA speed to 9600.

=== Set up ntpd to run at boot time ==

//FIXME: More to go here.

In /etc/init.d/ntp, comment out these lines

------------------------------------------------------------------------
if [ -e /var/lib/ntp/ntp.conf.dhcp ]; then
      NTPD_OPTS="$NTPD_OPTS -c /var/lib/ntp/ntp.conf.dhcp"
fi
------------------------------------------------------------------------

== Simplification and optimization ==

=== On Jessie: uninstall systemd ===

If you are running on Raspbian Jessie, an optional but recommended
step is to uninstall systemd.  It is a CPU hog (not just on the Pi;
similar problems have been reported across many architectures) and a
complexity sinkhole. The things that have it as a dependency are
things you don't want on a headless NTP server.

Note that if you do this you may lose the ability to upgrade from
jessie to the upcoming stretch release, and might need to rebuild your
image from scratch as a result.

(Our instructions are based on <<NO-SYSTEMD>>)

First, pull in the core of sysvinit, preserving the inittab that
systemd generated. Then reboot.

------------------------------------------------------------------------
# apt-get install sysvinit-core sysvinit-utils
# cp /usr/share/sysvinit/inittab /etc/inittab
# reboot
------------------------------------------------------------------------

Purge the remnants of systemd and packages that depend on it.

------------------------------------------------------------------------
# apt-get remove --purge --auto-remove systemd
------------------------------------------------------------------------

Prevent apt from installing systemd packages in the future by
creating an /etc/apt/preferences.d/systemd that looks like this.

------------------------------------------------------------------------
# Prevent apt from installing systemd packages in the future
Package: systemd
Pin: release *
Pin-Priority: -1
# Prevent apt from installing any systemd like packages in the future
Package: *systemd*
Pin: release *
Pin-Priority: -1
------------------------------------------------------------------------

=== Thin out the system processes on your Pi ===

The Raspbian default is to install a lot of background processes that
exist to support a graphical desktop. Installing from the Lite image
eliminates most of these.  This reduces load variability on the
processor, which will will decrease your time jitter.  It will also
cut your power draw and heat dissipation, increasing the Pi's expected
lifetime.  Most importantly, it will reduce the number of ways for
things to go wrong.

You can strip down a bit further with these commands:

------------------------------------------------------------------------
# apt-get -y remove --purge bluez
# apt-get -y remove --purge triggerhappy
# apt-get -y autoremove
# apt-get -y update
------------------------------------------------------------------------

The resulting configuration is pretty minimal, as you can verify by
running "ps ax" and noticing that most of the background processes are
kernel threads.

WiFi is deliberately not removed, in order to give
you a fallback TCP/IP access when a cable is inconvenient.

=== Configuring for a static IP address ==

You can choose to configure the SBC to use a fixed, static IP
address. That process is described in <<EAT-STATIC>>.

If you do this, and verify that it works, you
can remove avahi-daemon and dhcpd5, further
cutting the number of service processes running.

------------------------------------------------------------------------
# apt-get -y remove --purge avahi-daemon dhcpd5
------------------------------------------------------------------------

Once you do this, the SBC will no longer be accessible at a ".local"
address.

== Edge-detection issues and new HATs ==

As the pps-gpio module is in April 2016 it has a flaw. It catches only
one edge of the PPS. You have a 50/50 chance you are seeing the
trailing edge rather than the leading edge (which is the actual top of
second).  A patch to fix this has been submitted to the Linux kernel
maintainers but not merged.

Which edge the kernel will see, and the pulse width, are constant
depending on the GPS type and firmware (and if you can find a real
datasheet for the GPS engine it will tell you the pulse width). If the
kernel sees the trailing edge, the width of the pulse emitted by your
GPS will introduce a fixed lag from top of second to the time when you
actually see the PPS.

Pulse widths (and the induced lag) range from so fast the serial
driver can't see them to, worst case, 0.5s.  The worst case is rare;
typical pulse widths are 50 to 200ms. Because the error is constant,
you can compensate it out with an offset if you know what it is.
HATs marked "leading edge" below do not require compensation.

[width="25%",frame="topbot",options="header"]
|===========================================================
|Type           | Chipset    | 1PPS width  | gps-ppio detects
|Adafruit HAT   | MTK3339    |   100ms     | leading edge
|Uputronics HAT | Ublox 8    |   100ms     | leading edge 
|SKU 424254     | Ublox 6    |   100ms     | leading edge
|===========================================================

//FIXME: Verify SKU 424254 info with a scope

These details will become relevant whenever we qualify a new HAT
for coverage in this HOWTO.  The important thing to check is whether
the pps-gpio driver triggers on leading or trailing edge.

== A note about the Odroid C2 ==

The Odroid C2 is an ARM-based hackerboard strongly resembling the
Raspberry Pi, but with better hardware and at a slighly higher price
point. The main connector on the Odroid is pin-compatible with the
40-pin Pi connector.  A company representative has stated that
forum.odroid.com/viewtopic.php?f=111&t=7660[the Adafruit HAT should
work with it]

This recipe has not been tested with the Odroid.  But we can give
some pointers towards making it work.

* Your configuration and first-login process will be slighly different,
  as your Odroid will be running a stock Ubuntu rather than Raspbian.

* The company rep says that the UART device is /dev/ttyS2 rather
  than /dev/ttyAMA0.

* The RPi 3 hack to disable serial interfaces won't be required.

* You will not be able to see PPS in a stock gpsmon. GPSD has a
  magic kludge for this that recognizes /dev/ttyAMA0 as special,
  but not /dev/ttyS2.

* For the same reason, you need to give gpsd /dev/ppsS0 as a
  command-line argument for it to see PPS. Thus:
 
------------------------------------------------------------------------
# ./gpsd -n -N -D 5 /dev/ttyS2 /dev/pps0
------------------------------------------------------------------------

We would welcome field reports to complete this recipe.

== Future Direction ==

Future versions of this HOWTO will broaden the hardware base to
include some BeagleBone variant.

== References ==

[bibliography]

- [[[STANDOFFS]]] https://www.adafruit.com/product/2336[Brass M2.5 Standoffs for Pi]

- [[2258]] https://www.adafruit.com/product/2258

- [[[PI-PINOUT]] https://www.element14.com/community/docs/DOC-73950/l/raspberry-pi-3-model-b-gpio-40-pin-block-pinout[Raspberry Pi 3 Model B GPIO 40 Pin Block Pinout]

- [[RASPBIAN]] https://www.raspberrypi.org/downloads/raspbian/[Raspbian downloads]

- [[[INSTALLATION]]]
  https://www.raspberrypi.org/documentation/installation/installing-images/linux.md[Installing Operating System Images Under Linux]

- [[[NTPSEC]]] https://www.ntpsec.org/[The NTPsec project]

- [[[REMOVE-SYSTEMD]]]
  http://without-systemd.org/wiki/index.php/How_to_remove_systemd_from_a_Debian_jessie/sid_installation[How to remove systemd from a Debian jessie/sid installation]

- [[[DOREY]]] http://www.briandorey.com/post/Raspberry-Pi-3-UART-Overlay-Workaround[Raspberry Pi 3 UART Overlay Workaround]

- [[[ADAFRUIT-SETUP]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/pi-setup[Pi GPS Setup]

- [[[ADAFRUIT-TEST]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/basic-test[Basic Test]

- [[[TAYLOR]]] http://www.satsignal.eu/ntp/Raspberry-Pi-quickstart.html[RPi quick start]

- [[[NEVILL]]] https://darksky.io/setting-up-a-stratum-1-ntp-server-on-a-raspberry-pi.html[Setting up a Stratum 1 NTP server on a Raspberry Pi]

- [[NMEA-DRIVER]] https://docs.ntpsec.org/latest/driver20.html

- [[[EAT-STATIC]]] http://www.modmypi.com/blog/tutorial-how-to-give-your-raspberry-pi-a-static-ip-address[Tutorial - How to give your Raspberry Pi a Static IP Address]

== Acknwledgememts ==

Various devteam members and friends of the GPSD and NTPsec projects
assisted with this HOWTO, including: Gary E. Miller, Hal Murray, and
Phil Salkie.

== Other resources ==

http://ava.upuaut.net/?p=726[Not quite 5 minute guide to making an NTP Server]

//TO DO:
// SKU 424254
// http://www.raspberrypiwiki.com/index.php/Raspberry_Pi_Add-On_GPS_HAT_Module
// http://www.digikey.com/product-detail/en/seiko-instruments/XH414H-IV01E/728-1038-1-ND/1631941?WT.srch=1&gclid=Cj0KEQjwo_y4BRD0nMnfoqqnxtEBEiQAWdA121uytiEWyuT3qkSmZFXC2OVk8SEZOOc6iLZEvuKx3nAaAvgp8P8HAQ#substitute-section
// How to set stationary mode on the u-blox 8.

//end
