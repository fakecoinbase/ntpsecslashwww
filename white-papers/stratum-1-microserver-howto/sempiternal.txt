== SemPiTernal: A Raspberry Pi Stratum 1 timeserver build ==
:description: Building and configuring a tiny Stratum 1 timeserver with RasPi
:keywords: Raspberry Pi, odroid, NTP, NTPsec, time service
by Eric S. Raymond
version 0.3

== Introduction ==

This HOWTO gives complete instructions for building a headless Stratum
1 timeserver using a Raspberry Pi, a GPS daughterboard designed for
the Pi, and NTPsec <<NTPSEC>>.  Total parts cost should be about $80.
Beginner-level light soldering is required.

Why do it?  It's cheap, fun, and because your NTP server is running on
a dedicated machine you won't have so much jitter due to variable
load.

A GPS daughterboard (what Pi folks call a HAT after the Pi's interface
specification, Hardware Attached on Top) is a better idea than an
external GPS because a HAT uses an internal RS-232 interface that cuts
latency and jitter compared to a USB GPS, and provides the 1PPS
signal required for precision time service.  Generic USB GPSes do not
deliver this signal and therefore cannot be used for Stratum 1
service footnote[There is one USB GPS, the GR601-W, that provides 1PPS.
Unfortunately, it is difficult to purchase in the U.S.].

Most of this build is actually independent of any one daughterboard's
hardware idiosyncracies. The recipe was tested using an Adafruit GPS
HAT <<ADAFRUIT-HAT>>, but should also cover the Uputronics GPS
Expansion Board <<UPUTRONICS-HAT>>.

The build may also generalize to other HAT-compatible Unix SBCs such as
the ODROID C2, though details of those remain to be filled in.

== Parts list and hardware assembly ==

You will need:

* One Raspberry Pi.  I used a Raspberry Pi 3: these instructions cover
  older variants as well.

* One Adafruit GPS HAT or Uputronics GPS Expansion Board.

* One CR1220 (for Adafruit) or CR2032 (for Uputronics) 3-volt lithium
  coin cell.  The CR1220 is cheapest ordered from Adafruit along with
  the HAT, but you can buy either at most places that carry
  hearing-aid batteries.

* (Optional) A Raspberry Pi case to protect your hardware from
  dust and curious felines.

* (Optional) A micro-SD reader/writer, in case you need to recover
  from a failed installation by making a new bootable image.

* A live Ethernet cable to the Internet.

* Temporary of a USB mouse and keyboard.

* Temporary use of a DVI-compatible monitor and cable.

The Adafruit HAT is shipped as two parts, a circuit board and a 40-pin
header.  Your first step will be to solder the header to the bottom of
the board, on the opposite side from the GPS module (under what would
be the east edge if the Adafruit logo were a map legend). Poke the
header pins upwards through the double row of through holes at the
east edge of the board and go.  This is the last bit of hardware
hacking absolutely required.

(The device is shipped as parts almost certainly to evade a regulatory
requirement for FCC conformance testing to RF emission standards,
which is expensive and would have added to the unit cost.)

The header on the assembled HAT fits down over the
double row of pins on the east edge of the Pi, such that the two
boards make a neat stack.

== Understanding the GPIO connector ==

The pins you'll plug the HAT into are the Pi's primary or P1 GPIO
(General Purpose I/O) header.  There's a second or P5 GPIO connector
near it consisting of a 2x3 array of through holes. This build won't
use that.

The Pi 3 and other recent variants have 40 pins in the P1 header.
Older variants, the original Pi A and B, have only 26 pins.  The
assignments for those pins on later versions are backward-compatible.

The GPIO pins are sometimes referenced by physical pin location on the
header (1-26 or 1-40), and sometimes as the GPIO line connected to the
CPU.  This can cause confusion.  They are best referred to as
P1-[1-40], P5-[1-8] or as GPIO [0-31].  Some are typically
pre-configured for specific functions (serial, i2c, etc.)  Two that
will be important for this build are the TX and RX serial lines.

The pinouts are described at <<GPIO>>.

== Configuration overview ==

The steps in this configuration sequence have been carefully ordered
to commit you to as few changes that are difficult to reverse as
possible before you are certain you can make the hardware work as
a dedicated timeserver.

The work divides into the following phases:

1. Early configuration

2. Smoke-test the Pi/HAT combination

3. Live-test the GPS

4. Build and configure NTPsec

5. Simplification and optimization

Within each phase, we try to indicate how difficult each operation is
to back out.

If all else fails, we'll give a procedure for making a new bootable SD
which, unlike the "official" one, can be done entirely with a Unix
machine.

== Early configuration ==

== Initial configuration in the GUI ==

Plug in a monitor, a mouse, and keyboard, and a live Ethernet cable;
power up the Pi. Go through your normal configuration - hostname,
keyboard layout, timezone, locale, etc.

One special thing you should do is disable the serial interface.  Your
HAT needs the GPIO pins it uses, and it's easiest to disable from the
GUI configurator.  This change is easily reversed until and unless
you strip out the GUI in phase 6.

Next, check to see if you can expand the filesystem on the SD card;
the option may be active or frozen depending on how your SD card was
made.

You can do the build without expanding, but it gives you more space
for experiments. You should do this now if you're going to, because
you may lose the option to expand later in the process if you strip
out unused services.  Note that this change is *not reversible*;
however, you would probably want it for any other use of the Pi.

=== Runnlng headless ===

No actual configuration changes to the Pi are made in this step.

After initial configuration, the rest of your timeserver setup will be
done in a terminal emulator.  This will not require the GUI.
Optionally, you can continue using it.

Otherwise you can at this point begin to run headless, whuch you are
almost certainly going to want to do anyway when you put the Pi into
peoduction as a dedicated timeserver. Run this:

------------------------------------------------------------------------
$ ifconfig
------------------------------------------------------------------------

The output should contain a stanza roughly resembling this:

------------------------------------------------------------------------
eth0      Link encap:Ethernet  HWaddr b8:27:eb:05:b3:29  
          inet addr:192.168.1.184  Bcast:192.168.1.255  Mask:255.255.255.0
          inet6 addr: 2001:470:e34c:2::454/128 Scope:Global
          inet6 addr: 2001:470:e34c:2:4273:1f68:840c:489a/64 Scope:Global
          inet6 addr: fe80::e32f:9024:237f:5fc/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:16059 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8453 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:10589511 (10.0 MiB)  TX bytes:880938 (860.2 KiB)
------------------------------------------------------------------------

The key piece of information is the IP address just after "inet
addr:", in this case 192.168.1.184. Test this by running the
equivalent of

------------------------------------------------------------------------
$ ssh pi@192.168.1.184
------------------------------------------------------------------------

from a different machine on your network, using whatever address you
actually got.  You should be able to log in using the default password
for the pi user. Once you can do that, you can unplug the
mouse/keyboard/monitor on the Pi and run headless.

Note that by default the Pi gets a dynamic IP address from whatever
DHCP server it can find on your network - usually your router will
provide DHCP.  This means that when you reboot the Pi it may come up
using a different dynamic address that you don't know.

There are two ways around this.  One is to be sure the avahi-demon
package is installed on your Pi.  If it is, you can append ".local"
to your Pi's hostname (by default, then, "raspberrypi.local") and
ssh in using that name.

The other way around is to configure the Pi to use a fixed, static IP
address.  We'll give directions on how to set that up later in this
HOWTO.

If all else fails,

------------------------------------------------------------------------
# arp -a
------------------------------------------------------------------------

run from any machine on your network, will give you a list of
IP-addresses/hostnames that are or have been active on your network
(the information is cached).  You can try any IP addresses paired with
your Pi's hostname; one of them should work.

=== Fully update Raspbian ===

Fully update the Raspbian on your Pi.  The easiest way to do this is
with these commands:

------------------------------------------------------------------------
# apt-get update
# apt-get dist-upgrade
# rpi-update
------------------------------------------------------------------------

The '#' means you need to be root to run them. Later, some commands
won't require root; those command lines will be marked with "$".

If you skip this step on an old enough Pi, 1PPS configuration will
mysteriously fail because the required incantations have changed.

These changes are not reversible, but you'd want them for any other
use of the Pi anyway.

=== Pi 3 only: disable Bluetooth and remap console device ===

The Pi 3 Raspbian implementors made a design decision on the Raspberry
Pi 3 that ties the serial baud rate to the CPU clock rate (by
default).  This was done because the normal lines that fed the serial
port were used for the built-in Bluetooth. This does not affect any
other Pi variant.

Your timeserver is not going to need Bluetooth, so you should
disable it and remap the devices.  Our instructions come from
<<DOREY>>, which explains the problem in more detail.  We don't use
some of his steps because this build is designed to run headless.

Check that you have the file
/boot/overlay/pi3-miniuart-bt-overlay.dtb; if you don't, you can
http://www.briandorey.com/docs/Raspberry-Pi-3-UART-to-gpio-workaround/pi3-miniuart-bt-overlay.zip[download]
it.

Edit the /boot/config.txt file to append these lines:

------------------------------------------------------------------------
# Disable Bluetooth so serial-tty speed is no longer tied to CPU speed
dtoverlay=pi3-miniuart-bt-overlay
force_turbo=1
------------------------------------------------------------------------

This change restores the behavior of the Pi2 and earlier, in which the
serial device attached to the UART is /dev/ttyAMA0 rather than /dev/ttyS0.

This change can effectively be reversed by commenting out the
dtoverlay and force_turbo lines.

=== Release the console pins ===

Next, edit the boot command line (if required - if you remembered to
disable the serial interace in phase 1 it shouldn't be). You need to
be root to do this.

Save a copy of the original /boot/cmdline.txt before modifying it.

This is what I saw on an unmodified Pi 3 running Jessie:

------------------------------------------------------------------------
root@whoville:/home/pi# cat /boot/cmdline.txt
dwc_otg.lpm_enable=0 console=serial0,115200 console=tty1 root=/dev/mmcblk0p7 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait
------------------------------------------------------------------------

To disable the serial console, remove all "console" options.  The
Adafruit setup document <<ADAFRUIT-SETUP>> page mentions a "kgdboc"
option; if present, it should also be removed.

You must reboot the Pi for this change to take effect.

This change can be undone by restoring the saved original of /boot/cmdline.txt,
or by using the GUI configurator to re-enable serial interfaces.

== Smoke-test the GPS/HAT combination ==

To test that you can read data from the device, do this:

------------------------------------------------------------------------
$ stty -F /dev/ttyAMA0 raw 9600 cs8 clocal -cstopb
$ cat /dev/ttyAMA0
------------------------------------------------------------------------

You should see NMEA0183 sentences issuing in bursts once per second -
text lines usually beginning with "$GP", and possiblt a "$PMTK"
sentence.  These will issue whether or not the GPS has satellite lock.

If you see no output or random baud barf, re-do the stty command being
very careful that all the arguments are correct. If you still don't
see output, check that the HAT is correctly seated on the GPIO and
powered up (a red light near the north edge should blink at least once
per 10 seconds).

If you still don't see legible output after checking these, you may
have a problem this HOWTO can't solve - possibly dead or defective
hardware.  However, it is far more likely that you have skipped
a previous step or gotten one slightly wrong. Recheck your work.

This was not a full functional test of the GPS; we'll do that latter.
It's what engineers call a "smoke test", just checking that the
device is alive and doing something reasonably sane.

Once the GPS/HAT combination has passed its smoke test you can proceed.

You'll need NTPsec to be able to see the high-precision PPS
(pulse-per-second) signal from the GPS.  But the serial interface from an
Adafruit or Uputronics HAT only supplies TX/RX; the PPS signal is
shipped on a different pin of the GPIO connector.

The RX/TX signals are always expected on the same two pins of the
GPIO, which connect to the Pi's UART. You can see them, labeled, near
the north end of the connector. Most other GPIO pins can be
interpreted by the Pi in different ways, configured by software.
Which pin is used for 1PPS is a variable of the HAT design.  Here is a
table:

[width="25%",frame="topbot",options="header"]
|============================================
| Logical pin   | Physical pin  | HAT
|   GPIO #4     |      P1 7     | Adafruit
|   GPIO #18    |      P1 12    | Uputronics
|============================================

There is a different, non-HAT Adafruit product, the "Ultimate GPS
Breakout Board", that also uses GPIO #18.  This may be a source of
confusion if you read some of the references in this document.

There is a Linux kernel driver called pps-gpio which,
given one of these pins, uses the signal from it to support an
RFC2783 interface to PPS that NTPsec (and GPSD) can use.  To
see 1PPS, you need to ensure that this driver is loaded
and monitoring the correct logical pin.

In all versions, you force the driver to be loaded by
editing /etc/modules to contain the line "pps-gpio".

The procedure for declaring the GPIO pin varies by Raspbian version.
We only give the formula for the current Raspbian here; you can
find details about older versions at <<TAYLOR>>;

Edit /boot/config.txt to contain these options, replacing '4' with
the logical pin number for your HAT if it's not an Adafruit:

------------------------------------------------------------------------
dtoverlay=pps-gpio,gpiopin=4
------------------------------------------------------------------------

Any previous gpiopin option (such as bcm2708.pps_gpio_pin) should be
removed.

You must reboot your Pi for this change to take effect.

To test this change, use ppstest from the pps-tools package.  Note,
this will produce a false negative if the GPS has no fix.

------------------------------------------------------------------------
# apt-get install pps-tools
# ppstest /dev/pps0
------------------------------------------------------------------------

You should see repeated lines somewhat resembling this:

------------------------------------------------------------------------
source 0 - assert 1461161753.267392352, sequence: 246 - clear  0.000000000, sequence: 0
------------------------------------------------------------------------

If you can see this, you have 1PPS and can do proper timekeeping.

== Live-test the GPS ==

Next thing you want to do is verify that the GPS works.  Put your
Pi on someplace like a windowsill with a good sky view outside.
The HATs this HOWTO describes have very good weak-signal discrimination and
are much less fussy about siting than older GPS receivers.

On first (cold) boot, the device may take 20-30 minutes to download a
satellite ephemeris. After that, time to get a fix should be much faster
unless you live in a canyon (including the urban kind) or dense forest.
I, living in a suburb with the front of my house half-screened by tall
trees, typically get lock about 30 seconds from power up.  It will
seem longer than it is first time: have patience.

(Some material in this section is from <<ADAFRUIT-TEST>>.)

When the red LED on the HAT blinks once per second, you don't have a
satellite fix. When it achieves lock it will blink with much lower
frequency.

Now install GPSD.  You won't use this for production, as we plan to
direct-connect NTPsec to the GPS, but its diagnostic tools (especially
gpsmon) are useful for sanity-checking the output of the HAT.

It's best to clone the GPSD repository and build from that rather
than installing the Raspbian package.  This both guarantees you
the latest fixes and avoids instilling a start-on-boot script
that you don't want in this build.

The prerequisites not present in a stock Raspbian can be covered with
this import:

------------------------------------------------------------------------
# apt-get install scons ncurses-dev python-dev bc
------------------------------------------------------------------------

Then do this:

------------------------------------------------------------------------
$ git clone git://git.savannah.nongnu.org/gpsd.git
$ cd gpsd
$ scons
------------------------------------------------------------------------

Then run this: 

------------------------------------------------------------------------
# ./gpsmon /dev/ttyAMA0
------------------------------------------------------------------------

Running gpsmon should give you a nice panel display with a scrolling
window at the bottom showing the raw data and a top section showing
the analyzed fix and time to the second.

If you have a fix, you should also see bars denoting 1PPS once per
second between sentence bursts.  If you have a fix and *don't* see
these, most likely you have forgotten to go root before running
gpsmon.

Having run this step, you now know that both data and 1PPS from the
HAT are fully visible from userspace on your Raspberry Pi.  You can
now proceed with specializing it to be a time server.

== Build and configure NTPsec ==

The stock ntpd shipped with Raspbian is intended to be used as a
client instance, not a server.  It doesn't do 1PPS, and therefore
can't be used for precision timekeeping.  Thus, we're going to build a
better version from source.  That version is NTPsec, which runs
lighter and more securely and can do more accurate time stepping.

Uninstall the stock Raspbian NTP and tell apt-get upgrade:

------------------------------------------------------------------------
# apt-get -y remove --purge ntp
------------------------------------------------------------------------

Then, clone the NTPsec repository:

------------------------------------------------------------------------
$ git clone https://gitlab.com/NTPsec/ntpsec.git
------------------------------------------------------------------------

Install the build prerequisites

------------------------------------------------------------------------
# apt-get install bison libevent-dev libcap-dev libssl-dev
# apt-get install libreadline-dev asciidoc
------------------------------------------------------------------------

Build NTPsec.  The --refclock option says to include only Generic
NMEA and 1PPS support, excluding all other drivers.

------------------------------------------------------------------------
$ git clone https://gitlab.com/NTPsec/ntpsec.git
# cd ntpsec
$ waf configure --refclock=20,22
$ waf build
------------------------------------------------------------------------

Next, create symlinks to the GPS devices to make them easier to refer
to.  Put the following in a new file /etc/udev/rules.d/10-pps.rules to
accomplish this.

------------------------------------------------------------------------
KERNEL=="ttyAMA0", SYMLINK+="gps0"  
KERNEL=="pps0", OWNER="root", GROUP="tty", MODE="0660", SYMLINK+="gpspps0"
------------------------------------------------------------------------

At boot time this will ensure that device aliases /dev/gps0 and
/dev/gpps0 exist.  These are special names that NTPsec expects to see
when its Generic NMEA drive is active.

According to <<NEVILL>>, "[dhcpcd5] has a nasty habit of interfering where
it's not wanted. Specifically, in this instance, if your DHCP server
specifies an NTP server, it will start ntpd with its own version of
ntp.conf."

Look at /lib/dhcpcd/dhcpcd-hooks/50-ntp.conf to see if the hook script
exists.  If so, move it to a safe place (like your home directory) in
case you want to revert this change later.  You may want to similarly
stash /var/lib/ntp/ntp.conf.dhcp which is the autogenerated config file.

Create your own /etc/ntp.conf with this contents:

------------------------------------------------------------------------
# /etc/ntp.conf, configuration for ntpd; see ntp.conf(5) for help

# Local
server 127.127.1.0  
fudge 127.127.1.0 stratum 10

# GPS with PPS enabled
server 127.127.20.0 mode 17 minpoll 4 maxpoll 4 iburst true prefer  
fudge 127.127.20.0 flag1 1 refid GPS

# Internet time servers for sanity
server 0.pool.ntp.org iburst prefer  
server 1.pool.ntp.org iburst  
server 2.pool.ntp.org iburst  
server 3.pool.ntp.org iburst

# By default, exchange time with everybody, but don't allow configuration.
restrict default kod nomodify notrap nopeer noquery  
restrict -6 default kod nomodify notrap nopeer noquery

# Local users may interrogate the ntp server more closely.
restrict 127.0.0.1  
restrict -6 ::1

# Drift file etc.
driftfile /var/lib/ntp/ntp.drift
------------------------------------------------------------------------

Here's what the parts mean:

Local::
   This section sets up a local clock that nptd can refer to if
   it can't connect to anything else.

GPS with PPS enabled::
   This section specifies the particulars for our GPS setup.
+
The line beginning "server 127.127.20.0" tells it that we have a serial GPS
receiver on /dev/gps0.

The text "mode 17" tells it to look for $GPRMC messages at a baud of 9600bps.

The line "fudge 127.127.20.0" tells it that we have some further
configuration for our GPS

flag1 1 tells it that we have a PPS interface from our GPS on /dev/gpspps0.

refid GPS tells it to label this time source with the reference "GPS".

Full documentation for the NTPsec NMEA driver can be found at <<NMEA-DRIVER>.

Internet time servers for sanity::
   This section specifies some NTP pool servers to act as a sanity
   check for our GPS time. They will also keep the time accurate if
   your GPS loses signal.

//FIXME: More to go here.  Use <<NEVILL>>
//Things still to be documented include:
//1. Testing ntpd
//2. Startup installation scripts, including aetting AMA speed to 9600.

== Simplification and optimization ==

=== On Jessie: uninstall systemd ===

If you are running on Raspbian Jessie, an optional but recommended
step is to uninstall systemd.  It is a CPU hog (not just on the Pi;
similar problems have been reported across many architectures) and a
complexity sinkhole. The things that have it as a dependency are
things you don't want on a headless NTP server.

(Our instructions are based on <<NO-SYSTEMD>>)

First, pull in the core of sysvinit, preserving the inittab that
systemd generated. Then reboot.

------------------------------------------------------------------------
# apt-get install sysvinit-core sysvinit-utils
# cp /usr/share/sysvinit/inittab /etc/inittab
# reboot
------------------------------------------------------------------------

Purge the remnants of systemd and packages that depend on it.

------------------------------------------------------------------------
# apt-get remove --purge --auto-remove systemd
------------------------------------------------------------------------

Prevent apt from installing systemd packages in the future.

------------------------------------------------------------------------
# echo -e 'Package: systemd\nPin: release *\nPin-Priority: -1' > /etc/apt/preferences.d/systemd
------------------------------------------------------------------------

Prevent apt from installing any systemd like packages in the future (note the star before and after systemd)

------------------------------------------------------------------------
# echo -e '\n\nPackage: *systemd*\nPin: release *\nPin-Priority: -1' >> /etc/apt/preferences.d/systemd
------------------------------------------------------------------------

//FIXME: Show what /etc/apt/preferences.d/systemd will look like after this.

=== Thin out the system processes on your Pi ===

The Raspbian default is to install a lot of background processes that
exist to support a graphical desktop. Running headless with Ethernet
as the only channel to the device, you can remove these in order to
reduce load variability on the processor.  This will decrease your
time jitter.  It will also cut your power draw and heat dissipation,
increasing the Pi's expected lifetime.  Most importantly, it will
reduce the number of ways for things to go wrong.

------------------------------------------------------------------------
# apt-get -y remove --purge xserver-common
# apt-get -y remove --purge x11-common
# apt-get -y remove --purge gnome-icon-theme
# apt-get -y remove --purge gnome-themes-standard
# apt-get -y remove --purge penguinspuzzle
# apt-get -y remove --purge desktop-base
# apt-get -y remove --purge desktop-file-utils
# apt-get -y remove --purge hicolor-icon-theme
# apt-get -y remove --purge raspberrypi-artwork
# apt-get -y remove --purge omxplayer
# apt-get -y remove --purge bluez
# apt-get -y remove --purge triggerhappy
# apt-get -y autoremove
# apt-get -y update
# rm -rf /home/pi/python_games
------------------------------------------------------------------------

The resulting configuration is pretty minimal, as you can verify by
running "ps ax" and noticing that most of the background processes are
kernel threads.

Be careful not to remove avahi-daemon unless you have previously
configured your Pi to have a static IP address.

WiFi is deliberately not removed, in order to give
you a fallback TCP/IP access when a cable is inconvenient.

== Edge-detection issues and new HATs ==

As the pps-gpio module is in April 2016 it has a flaw. It catches only
one edge of the PPS. You have a 50/50 chance you are seeing the
trailing edge rather than the leading edge (which is the actual top of
second).  A patch to fix this has been submitted to the Linux kernel
maintainers but not merged.

Which edge the kernel will see, and the pulse width, are constant
depending on the GPS type and firmware (and if you can find a real
datasheet for the GPS engine it will tell you the pulse width). If the
kernel sees the trailing edge, the width of the pulse emitted by your
GPS will introduce a fixed lag from top of second to the time when you
actually see the PPS.

Pulse widths (and the induced lag) range from so fast the serial
driver can't see them to, worst case, 0.5s.  The worst case is rare;
typical pulse widths are 50 to 200ms. Because the error is constant,
you can compensate it out with an offset if you know what it is.

[width="25%",frame="topbot",options="header"]
|===========================================================
|Type           | Chipset    | 1PPS width  | gps-ppio detects
|Adafruit HAT   | MTK3339    |   100ms     | leading edge
|Uputronics HAT | Ublox 8    |   100ms     | leading edge 
|===========================================================

These details will become relevant whenever we qualify a new HAT
for coverage in this HOWTO.  The important thing to check is whether
the pps-gpio driver triggers on leading or trailing edge.

== A note about the ODROID C2 ==

The ODROID C2 is an ARM-based hackerboard strongly resembling the
Raspberry Pi, but with better hardware and at a slighly higher price
point. The main connector on the ODROID is pin-compatible with the
40-pin Pi connector.  A company representative has stated that
forum.odroid.com/viewtopic.php?f=111&t=7660[the Adafruit HAT should
work with it]

This recipe has not been tested with the ODROID.  But we can give
some pointers towards making it work.

* The company rep says that the UART device is /dev/ttyS2 rather
  than /dev/ttyAMA0.

* The RPi 3 hack to disable serial interfaces won't be required.

* You will not been able to see PPS in a stock gpsmon. GPSD has a
  magic kludge for this that recognizes /de/ttyAMA0 as special,
  but not /dev/ttyS2.

* Fotr the same reason, you need to give gpsd /dev/ppsS0 as a
  command-line argument for it to see PPS. Thus:
 
------------------------------------------------------------------------
# ./gpsd -n -N -D 5 /dev/ttyS2 /dev/pps0
------------------------------------------------------------------------

We would welcome field reports to complete this recipe.

== Reverting to a stock Raspbian ==

When doing as much hackery on a Pi as we've described, it is wise to
have a way to revert to a stock Raspbian in case the installation
goes wrong.  Here's how to do it.

You will need a spare MicroSD card with at least 8GB capacity. You
will also need a USB MicroSD reader/writer, or one built into a
computer you have.  We'll describe USB setup under a Debian-derived
Linux here; device names might be slightly different on other
variants.

. Download the NOOBS zip file from <<NOOBS>>.

. Do "ls /dev/sd*".  Note which devices exist; they are most likely
  to be sda (hard drive), sdb (hard drive) and sdc (CD-ROM/DVD).

. Insert the card in the reader and plug the reader into a USB port.

. Do "ls /dev/sd*". You should see an additional device, most likely /dev/sdd.

. If you don't see a new device, do "lsusb" to check what USB devices
  exist, with the reader first unplugged and then plugged in.  You
  should see one asdditional USB device line when it's plugged in. If you
  don't, you have a USB-layer or hardware problem beyond the scope of
  this HOWTO.

. As root, do "fdisk /dev/sdd" (or substitute whatever new device you
  found for sdd).  Do 'l' to check the partition names.  What you will
  probably see is a single partition named for the device with the
  suffix "1" - most likely, sdd1.

. As root, moount the card. The command "mount /dev/ssd1 /media" will
  probably be right.  Any empty directory will do as as a mount point, 
  there is noting magic about "/media".

. Change current directory to the root dictory of the card
  (e.g."/meda") and run "unzip" with the NOOBS zip as argument.

. Unmount the card (e.g. "umount /dev/sdd").

You will now have a card that can be booted in the Pi.

== References ==

[bibliography]

- [[[ADAFRUIT-HAT]]]
  https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi[Adafruit
  GPS HAT]

- [[[UPUTRONICS-HAT]]] https://store.uputronics.com/index.php?route=product/product&path=60_64&product_id=81[Raspberry Pi+ GPS Expansion Board]

- [[[NTPSEC]]] https://www.ntpsec.org/[The NTPsec project]

- [[[GPIO]]] https://www.raspberrypi.org/documentation/usage/gpio-plus-and-raspi2/[GPIO: MODELS A+, B+, RASPBERRY PI 2 B AND RASPBERRY PI 3 B]

- [[[REMOVE-SYSTEMD]]]
  http://without-systemd.org/wiki/index.php/How_to_remove_systemd_from_a_Debian_jessie/sid_installation[How to remove systemd from a Debian jessie/sid installation]

- [[[DOREY]]] http://www.briandorey.com/post/Raspberry-Pi-3-UART-Overlay-Workaround[Raspberry Pi 3 UART Overlay Workaround]

- [[[ADAFRUIT-SETUP]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/pi-setup[Pi GPS Setup]

- [[[ADAFRUIT-TEST]]] https://learn.adafruit.com/adafruit-ultimate-gps-hat-for-raspberry-pi/basic-test[Basic Test]

- [[[TAYLOR]]] http://www.satsignal.eu/ntp/Raspberry-Pi-quickstart.html[RPi quick start]

- [[[NEVILL]]] https://darksky.io/setting-up-a-stratum-1-ntp-server-on-a-raspberry-pi.html[Setting up a Stratum 1 NTP server on a Raspberry Pi]

- [[NMEA-DRIVER]] https://docs.ntpsec.org/latest/driver20.html

- [[[NOOBS]]] https://www.raspberrypi.org/downloads/noobs/[NOOBS]

== Other resources ==

http://ava.upuaut.net/?p=726[Not quite 5 minute guide to making an NTP Server]
